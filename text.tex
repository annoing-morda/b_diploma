\documentclass[pdftex,ptm,12pt,a4paper]{report}
\renewcommand{\baselinestretch}{1.5}
\setcounter{secnumdepth}{5}

% PDF search & cut'n'paste
\usepackage{cmap}

% Cyrillic support
\usepackage{mathtext}
\usepackage[T1,T2A]{fontenc}
\DeclareSymbolFont{T2Aletters}{T2A}{cmr}{m}{it}
\usepackage[utf8]{inputenc}

\usepackage[bottom=20mm,top=20mm,right=20mm,left=30mm,headsep=0cm,nofoot]{geometry}

\makeatletter
\renewcommand*{\ps@plain}{%
  \let\@mkboth\@gobbletwo
  \let\@oddhead\@empty
  \def\@oddfoot{%
    \reset@font
    \hfil
    \thepage
    % \hfil % removed for aligning to the right
  }%
  \let\@evenhead\@empty
  \let\@evenfoot\@oddfoot
}
\makeatother
\pagestyle{plain}
\setlength{\footskip}{30pt}

\newenvironment{Proof} % имя окружения
  {\par\noindent{\bf Доказательство.}} % команды для \begin
  {\hfill$\scriptstyle\blacksquare$}

\usepackage[pdftex]{graphicx}
\usepackage{caption}
\usepackage{subcaption}
\usepackage[english, russian]{babel}
    \addto{\captionsenglish}{\renewcommand{\bibname}{Литература}}
    \addto\captionsenglish{\renewcommand{\figurename}{Рис.}}
    \addto\captionsenglish{\renewcommand{\contentsname}{Содержание}}
    \addto\captionsenglish{\renewcommand{\proofname}{Доказательство}}
\usepackage{hyperref}
\usepackage{url}
\usepackage{abstract}
\usepackage{float}
\usepackage{amsthm}
\usepackage{amssymb}
\usepackage{amsmath}
\renewcommand*{\proofname}{Доказательство}
\usepackage{indentfirst}
\usepackage{color}
\usepackage{natbib}
\usepackage{bbm, dsfont}
\usepackage{titlesec}
\usepackage{caption}

% Detect whether PDFLaTeX is in use
\usepackage{ifpdf}

% Fix links to floats
\usepackage[all]{hypcap}

%Formula packages
\usepackage{amsmath}

% Chapter
\makeatletter
\renewcommand{\@chapapp}{Часть}
\makeatother

\titleformat{\chapter}[display]
{\normalfont\huge\bfseries}
{\chaptertitlename\ \thechapter}{0.5ex}{}[]

\titlespacing*{\chapter}{0pt}{0pt}{40pt}

% Rule for Title Page
\newcommand{\HRule}{\rule{\linewidth}{0.5mm}}

\begin{document}

\begin{titlepage}
\newpage

\begin{center}{\small
МИНИСТЕРСТВО ОБРАЗОВАНИЯ И НАУКИ РОССИЙСКОЙ ФЕДЕРАЦИИ \\
\vspace{0.1cm}
ФЕДЕРАЛЬНОЕ ГОСУДАРСТВЕННОЕ АВТОНОМНОЕ  \\*
ОБРАЗОВАТЕЛЬНОЕ УЧРЕЖДЕНИЕ ВЫСШЕГО ОБРАЗОВАНИЯ \\*
"МОСКОВСКИЙ ФИЗИКО-ТЕХНИЧЕСКИЙ ИНСТИТУТ \\*
(ГОСУДАРСТВЕННЫЙ УНИВЕРСИТЕТ)" \\*
\vspace{0.1cm}
ФАКУЛЬТЕТ ИННОВАЦИЙ И ВЫСОКИХ ТЕХНОЛОГИЙ \\*
КАФЕДРА ФИЗИКО-ТЕХНИЧЕСКОЙ ИНФОРМАТИКИ \\*
\hrulefill
}
\end{center}

\begin{center}
\Large Выпускная квалификационная работа (бакалаврская работа)
\end{center}

\vspace{1em}

\begin{center}
\Large НА ТЕМУ:
\linebreak
\textsc{\large{\textbf{ПРОВЕРКА НАЛИЧИЯ ПЕРЕСЕЧЕНИЯ ТЕЛ В ТРЕХМЕРНОМ ПРОСТРАНСТВЕ}}}
\end{center}

\vspace{4em}

\begin{flushleft}
Студент \hrulefill Морозов Дмитрий Антонович \\
Научный руководитель \hrulefill Гуревич Михаил Исаевич\\
Зав. кафедрой \hrulefill Бутко Андрей Борисович\\
\end{flushleft}

\vspace{\fill}

\begin{center}
МОСКВА, 2017
\end{center}

\end{titlepage}

\tableofcontents

\clearpage

\chapter{Введение}
  \subsection{Неаналоговое моделирование в задаче переноса нейтронов}
    Частица --- это точка фазового пространства $(r,W,E)+w$, где $w$ – статистический вес.
    Статистический вес вводят для того, чтобы получить возможность исследовать поведение частиц в некоторых областях, искусственно увеличивая их число.
    Если статистический вес не вводится, полученные оценки будут смещенными.
    Чтобы получить несмещенные оценки,
    аналоговый вклад $h_0$ заменяется на вклад $h_n=h_0 w$.
    Математические ожидания $h_n$ и $h_0$ должны быть одинаковы.

    Частица в точке фазового пространства $x$ заменяется на $n$ частиц в той же точке:
    \[
      (r,W,E,w_0), (r,W,E,w_1) \dots (r,W,E,wn)
    \]
    Основное соотношение:
    \[
      \mathsf{E}(w_1) + \dots + \mathsf{E}(w_n) = \mathsf{E}(w_0)
    \]
    Есть два основных способа изменения числа частиц: расщепление и русская рулетка.
    При расщеплении частица заменяется на несколько частиц.
    Статистические веса новых частиц могут быть равными или могут быть случайными величинами, но обязаны удовлетворять основному соотношению
    В русской рулетке частица с вероятностью $p$ заменяется на новую весом $w_1 = \frac{w_0}{p}$, а с вероятностью $1-p$ уничтожается.
    Встает вопрос: как выбирать способ изменения частиц.
    Для выбора способа фазовое пространство разбивают на области ценности:
    \[
      X = X_1 \sqcup X_2 \sqcup \dots \sqcup X_n
    \]
    Для каждой оласти ценности $X_i$ задано свое значение ценности $I_i$.
    $I_j> I_k$ означает, что частицы в $X_j$ дают больший вкдад, чем частицы в $X_k$.
    Надо увеличивать число частиц в областях большей ценности.

    Весовое окно --- это cпособ управлять весом частицы только по фазовым координатам, практически независимо от предыдущего веса.
    Каждой области ценности $X_a$ соответствует нижний уровень окна $w_{ai}$
    Определены 2 константы: $1 < c_m < c_s  < 2$.
    Весовое окно определено тремя числами:
    $w_{ai}$, $w_{am}=c_m w_{ai}$, $w_{as}=c_s w_{ai}$.

    При попадании частицы веса $w_0$ в область ценности возможны следующие варианты:
    \begin{itemize}
      \item
        Вес частицы меньше нижнего порога весового окна.
        В этом случае запускается русская рулетка.
      \item
        Вес частицы внутри весового окна.
        В этом случае с чатицей ничего не делают.
      \item
        Вес частицы выше верхней границы весового окна.
        В этом случае частица расщепляется на $N$ частиц одинакового веса.
        $N$ выбирается таким образом, чтобы новые частицы попали в весовое окно.
    \end{itemize}

  \subsection{Описание подмодуля MCU СЕТКА}
    Подмодуль СЕТКА предназначен для задания нижней границы весового окна как функции точки фазового пространства $(r,u,E)$.
    Верхняя граница окна и средняя точка определяются стандартным для MCU способом с помощью управляющих карт.

    Используется весовое окно по столкновениям – пересечения границ геометрических зон не вызывают обращения к алгоритму весового окна. Для предотвращения слишком больших пробегов используется ограничение по оптической длине или по геометрической длине. По достижению заданного лимита происходит фиктивный выход из геометрического модуля и обращение к алгоритму весового окна. При этом фазовые координаты частицы не меняются – она продолжает свободный полет.

    Считается, что все геометрическое пространство, занятое системой, разбивается на несколько непересекающихся областей, занятых СЕТКАми и оставшуюся область. В каждой их них действует свое правило определения весовых окон и ограничения пробега.

    В оставшейся области имеется ровно одно определение весового окна. Либо это бесконечное окно, т.е. любой вес частицы считается законным и не корректируется, либо это одно окно со обычным отношением верха к низу. Низ окна задается пользователем. Бесконечное окно берется по умолчанию. Также в оставшейся области имеется ровно одно ограничение пробега, задаваемое пользователем. По умолчанию это отсутсвие ограничения.

    Для каждой области СЕТКи действует одно ограничение пробега, которое пользователь должен задать.
    Область СЕТКИ разбита на ячейки, для каждой из которых определена ценность ячейки vc. Для области может быть задана дополнительная зависимость от энергии и направления полета.

    СЕТКА привязана к своей системе координат. Могут использоваться три системы
      декартова, цилиндрическая, сферическая.

      СЕТКА в зависимости от типа системы координат может занимать области следующих форм:
      \begin{itemize}
        \item декартова --- параллелепипед, возможно бесконечный;
        \item цилиндрическая --- сектор цилиндрического слоя, возможно бесконечный вдоль оси; естественно рассматривать внешний и внутренний бесконечные цилиндры, верхнее и нижние не занятое цилиндром полупространство, и высекающий угол; обязательно реально присутствует лишь внешний бесконечный цилиндр;
        \item сферическая --- сегмент шарового слоя
      \end{itemize}

      Пересечение двух параллелепипедов проверяется полностью корректно.
      При проверке пересечения параллелепипеда и сектора цилиндрического слоя отсутствие пересечения принимается, если а) параллелепипед внутри внутреннего   бесконечного цилиндра, б) параллелепипед вне внешнего бесконечного цилиндра, в) параллелепипед внутри верхнего или нижнего не занятого цилиндром  полупространства.

      При проверке пересечения двух секторов цилиндрических слоев отсутствие пересечения принимается, если а) второй цилиндр вне первого внешнего бесконечного  цилиндра, б) второй цилиндр внутри верхнего или нижнего не занятого первым цилиндром полупространства.
      При проверке пересечения параллелепипеда и сектора сегмента шарового слоя отсутствие пересечения принимается, если параллелепипед не имеет общих точек с  внешним шаром.

      При проверке пересечения сектора сегмента шарового слоя и сектора цилиндрического слоя отсутствие пересечения принимается, если внешний шар не имеет  общих точек с внешним цилиндром.

      При проверке пересечения 2 секторов сегментов шаровых слоев отсутствие пересечения принимается, если отсутствует пересечений внешних шаров.

  \section{Цель работы}
      Целью работы является построение алгоритма, проверяющего наличие пересечения произвольных цилиндра и параллелепипеда.

      \textbf{Для достижения цели были решены следующие задачи}

      \begin{itemize}
        \item Описание алгоритма, проверяющего для двух заданных тел (цилиндра и параллелепипеда) наличие пересечений;
        \item Обосноваие корректности работы алгоритма;
        \item Написание программы, реализующей данный алгоритм.
      \end{itemize}

      \textbf{Актуальность работы}

        Разработанный алгоритм может быть использован в подмодуле СЕТКа программы MCU.
        Таким образом, задача актуальна в области численного моделирования в физике элементарных частиц.
        Вообще же задача обнаружения столкновений является актуальной и в других областях науки и техники:
        Она решается в физических движках, компьютерной анимации, робототехнике.

      \textbf{Новизна работы}

        В программе MCU ввод проверяется на корректность.
        В числе прочего пользователь может задавать цилиндрические области и области формы параллелепипеда.
        Требуется, чтобы они не пересекались.
        Однако вместо проверки наличия пересечений решается более частная задача проверки вложенности тел одно в другое.
        Предложенный в работе алгоритм позволяет уточнить проверку корректности ввода в программе MCU.

      \textbf{Личный вклад автора}

        \begin{itemize}
          \item Построение алгоритма для обнаружения столкновения произвольных цилиндра и параллелепипеда
          \item Имплементация алгоритма на языке Python
        \end{itemize}

    \section{Обзор литературы}
      [1] является аннотацией к одной из версий семейства программ MCU.

      В книге [2] излагаются основы теории метода Монте-Карло.
      Помимо этого, книга содержит изложение оригинальных методов, лежащих в основе типовых американских программ рассчета реакторов методом Монте-Карло.
      В ней рассматриваются конкретные задачи переноса нейтронов: расчет потока тепловых нейтронов, рассчет вероятности избежать резонансного захвата.

      В статье [3] описана версия MCU-5; кратко описаны созданные библиотеки констант и охарактеризованы возможности модулей пакета MCU-5 и собранных из них рабочих программ; приводятся примеры практически важных задач физики реакторов, для решения которых привлекались программы семейства MCU.

      Книга [4] является инструкцией по использованию пакета программ для рассчета переноса нейронов методом
      Монте-Карло MCNP. Содержит в себе информацию, необходимую для начала работы с программой, краткую информацию
      об использованных в программе MCNP математических и физичеких данных, а также инструкцию по подготовке
      ввода программы с примерами.

      Пособие [5] содержит информацию, необходимую для рассчета переноса нейтронов методом Монте-Карло
      с помощью универсальной программы MCU. Кроме того, в нем кратко изложены физические основы и принцип моделирования.

      Книга [6] cодержит различные алгоритмы численной оптимизации.
      В ней можно найти как описание, так и обоснование корректности методов численной оптимизации.
      В числе прочих алгоритмов и алгоритм минимизации квадратичной формулы на многограннике.
      В этой книге задача решена для  пространства произвольной размерности.
      В нашей задаче размерность пространства равна 3, и мы можем позволить себе упростить алгоритм, взяв, однако, некоторые идеи.

\section{Необходимые леммы}
\newtheorem{Lem}{Лемма}
\begin{Lem}\label{conv}
  Пусть $O$ --- точка, лежащяя в одной плоскости с выпуклым многоугольником $G$.
  Тогда если $O$ лежит вне многоугольника, то $\min\limits_{A \in G}\rho(A, O)$ достигается на границе многоугольника.
\end{Lem}
\begin{Proof}
  Предположим, что $M$ лежит внутри $G$, причем
  \[
    \min\limits_{A \in G}\rho(A, O) = rho(M, O) \neq 0
  \]
  Тогда отрезок $MO$ пересекает границу $G$, так как это выпуклое, а значит и непрерывное множество.
  Но точка пересечения лежит к $O$ ближе, чем $M$.
  Получили противоречие.
\end{Proof}

%\begin{Lem}\label{chstr4edge}
%  Про замену строчек в матрице для получения задачи квадртичного программирования
%%\end{Lem}
%%\begin{Lem}\label{chstr4check}
%  Пусть система
%  \begin{equation}\label{proof1stsys}
%    \begin{pmatrix}
%     x_a & x_b & x_c & \vrule & -x_o\\
%     y_a & y_b & y_c & \vrule & -y_o \\
%     z_a & z_b & z_c & \vrule & -z_o
%     \end{pmatrix}
%  \end{equation}
%  имеет единственное решение. Тогда система
%  \begin{equation}\label{proo2ndsys}
%    \begin{pmatrix}
%     x_a & x_b & x_c & \vrule & -x_o\\
%     y_a & y_b & y_c & \vrule & -y_o \\
%     0   & 0   & 1   & \vrule & 1
%     \end{pmatrix}
%  \end{equation}
%  также имеет единственное решение.
%%\end{Lem}
%%\begin{Proof}
%  Так как система \ref{proof1stsys} имеет единственное решение,
%  \[
%  rk \begin{pmatrix}
%   x_a & x_b & x_c \\
%   y_a & y_b & y_c \\
%   z_a & z_b & z_c
%   \end{pmatrix} = 3,
%  \]
%  так как по теореме Кронекера-Капелли система имеет единственное решение тогда и только тогда, когда ранг расширенной матрицы равен рангу основной
%  матрицы и равен числу аргументов
%  \[
%    det \begin{pmatrix}
%        x_a & x_b & x_c \\
%        y_a & y_b & y_c \\
%        0   & 0   & 1
%        \end{pmatrix} = det
%            \begin{pmatrix}
%              x_a & x_b \\
%              y_a & y_b
%            \end{pmatrix} \neq 0,
%  \] так как в случае равенства $0$ в \ref{proof1stsys} основная матрица была бы вырожденной и имела бы ранг, меньший $3$.
%  Значит, так как детерминант основной матрицы в \ref{proo2ndsys} не равен 0, она невырождена, и система имеет ровно одно решение по теореме Кронекера-Капелли.
%  Лемма доказана.
%%\end{Proof}

\chapter{Описание алгоритма}
    \section{Вход алгоритма и требования к нему}
      На вход алгоритма поступают цилиндр и параллелепипед в следующем формате.
      Цилиндр задан четырьмя векторами $\vec{o_c}, \vec{a_c}, \vec{b_c}, \vec{c_c}$ в трехмерном афинном пространстве.
      Вектор $\vec{o_c}$ задает центр одного из оснований.
      Вектор $\vec{a_c}$ задает одну из осей эллипса, лежащего в основании.
      Вектор $\vec{b_c}$ задает вторую ось эллипса, лежащего в основании.
      Вектор $\vec{ c_c}$ задает направляющую цилиндра.
      Координаты векторов должны быть заданы в ортонормированном базисе.
      Здесь имеется в виду, что программа считает исходный базис ортонормированным.
      Вектора $\vec{a_c}$ и $\vec{b_c}$ ортогональны.
      Вектора $\vec{a_c}$, $\vec{b_c}$ и $\vec{c_c}$ представляют собой линейно независимую систему векторов.

      Параллелепипед задан также четырьмя векторами: $\vec{o_p}, \vec{a_p}, \vec{b_p}, \vec{c_p}$.
      Вектор $\vec{o_c}$ задает одну из вершин.
      Вектора $\vec{a_p}$, $\vec{b_p}$ и $\vec{c_p}$ задают три непараллельных ребра, имеющих общую точку $\vec{o_p}$; эти вектора направлены от вершины $\vec{o_p}$.
      Требование лишь одно: вектора $\vec{a_p}$, $\vec{b_p}$ и $\vec{c_p}$ должны образовывать линейно независимую систему.

      После получения всех параметров при создании объектов соответствующих классов производится проверка корректности.
      В случае, если требования не выполнены, программа выдаст сообщение об ошибке.
\section{Преобразование базиса}
      Перенесем начало координат в точку $\vec{o_c}$.
      Вектора $\vec{a_c}$, $\vec{b_c}$ и $\vec{c_c}$ задают базис.
      Для этого базиса матрица перехода естественно определена:
      $N = \begin{pmatrix} {a_c} & {b_c} & c_{c} \end{pmatrix}$.
      Кроме того, введем новое скалярное произведение, определив матрицу Грама в новом базисе как единичную.
      Таким образом, в новом базисе цилиндр с внутреннотью задан системой неравенств
      \begin{equation}\label{cnb}
          \begin{cases}
          x^2 + y^2   \le  1  \\
          0 \le  z   \le  1
          \end{cases}
      \end{equation},

      где $\begin{pmatrix} x \\ y \\ z \end{pmatrix}$ --- координаты некоторой точки в новом базисе.

      В новом базисе легко получим координаты для векторов, задающих параллелепипед.
      Для $\vec{o_p}$:
      $\begin{pmatrix} x_o \\ y_o \\ z_o \end{pmatrix} =  N^{-1} (o_p - o_c) $, где $o_p$ и $o_c$ --- коодинаты соответствующих векторов в исходном базисе.

      Для $\vec{a_p}$, $\vec{b_p}$ и $\vec{c_p}$:
      $\begin{pmatrix} x_a & x_b & x_c \\ y_a & y_b & y_c  \\ z_a & z_b & z_c \end{pmatrix} =
      N^{-1} \begin{pmatrix} a_p & b_p  & c_p \end{pmatrix}$

      Параллелепипеду принадлежат точки $\vec{a}$, удовлетворяющие следующим условиям:
      \begin{equation}\label{pvec}
        \begin{cases}
          \vec{a} = \vec{o_p} + \alpha \vec{a_p} + \beta \vec{b_p} + \gamma \vec{c_p} \\
          0 \le  \alpha   \le  1 \\
          0 \le  \beta   \le  1 \\
          0 \le  \gamma   \le  1
        \end{cases}
      \end{equation}

      Перепишем (\ref{pvec}) в координатном виде с координатами, заданными в новом базисе.
      \begin{equation}\label{pcoord}
        \begin{cases}
          \begin{pmatrix} x \\ y \\ z \end{pmatrix}
          =
          \begin{pmatrix} x_o & x_a & x_b & x_c \\ y_o & y_a & y_b & y_c  \\ y_o & z_a & z_b & z_c
          \end{pmatrix} \begin {pmatrix} 1 \\ \alpha \\ \beta \\ \gamma \end{pmatrix} \\
          0 \le  \alpha   \le  1 \\
          0 \le  \beta   \le  1 \\
          0 \le  \gamma   \le  1
        \end{cases}
      \end{equation}

      Таким образом, задача сводится к проверке наличия решения у систем (\ref{cnb}) и (\ref{pcoord})
\section{Переход к задаче на гранях}
    Поскольку и цилиндр, и параллелепипед --- тела выпуклые, цилиндр или вложен в параллелепипед, или пересекается с гранями параллелепипеда, или не имеет с ним общих точек вовсе.
    Грань параллелепипеда задается, например, следующей системой:
    \begin{equation}\label{planecoord}
      \begin{cases}
        \begin{pmatrix} x \\ y \\ z \end{pmatrix}
        =
        \begin{pmatrix} x_o & x_a & x_b & x_c \\ y_o & y_a & y_b & y_c  \\ y_o & z_a & z_b & z_c
        \end{pmatrix} \begin {pmatrix} 1 \\ \alpha \\ \beta \\ \gamma \end{pmatrix} \\
        0 \le  \alpha   \le  1 \\
        0 \le  \beta   \le  1 \\
        \gamma   =  1
      \end{cases}
    \end{equation}

    Вместо $\gamma$ в 0 или 1 могут обратиться также $\alpha$ и $\beta$.
    Эти замены дадут нам шесть граней параллелепипеда.
\section{Переход к проекции}
    Для каждой грани необходимо установить наличие решение у системы неравенств следующего вида
    \begin{equation}\label{proj}
      \begin{cases}
        x^2 + y^2 \le 1 & (1)\\
        \begin{pmatrix} x \\ y \\ z \end{pmatrix}
        =
        \begin{pmatrix} x_o & x_a & x_b & x_c \\ y_o & y_a & y_b & y_c  \\ y_o & z_a & z_b & z_c
        \end{pmatrix} \begin {pmatrix} 1 \\ \alpha \\ \beta \\ \gamma \end{pmatrix} & (2)\\
        0 \le  \alpha   \le  1 & (3)\\
        0 \le  \beta   \le  1 & (4)\\
        \gamma   =  1 & (5) \\
        0 \le z \le 1 & (6)
      \end{cases}
    \end{equation}
  Правая и левая части (5) могут меняться в зависимости от выбранной грани.
  Будем рассматривать (6) как ограничение не на высоту цилиндра, а на грань.
  Поскольку (6) задает два линейных ограничения на $\alpha, \beta, \gamma$, поиск решения неравенства (1) будет вестись на некотором многоугольнике.
  Итак, ограничение на высоту цилиндра снято и заменено ограничением на грань.
  Так как цилиндр теперь бесконечный по высоте, можем спроецировать обе фигуры на плоскость $xOy$ и проверять на наличие пересечений выпуклый многоугольник и круг.
  Если они пересекаются, то либо точка пересечения лежит на ребре многоугольника, либо точек пересечения на ребрах нет, но центр круга лежит внутри многоугольника (см. Лемму~\ref{conv}).
  Проверим оба варианта.
\section{Перход к задаче квадратичного программирования}
    Подставим равенство из (\ref{planecoord}) в (\ref{cnb}) и добавим туда же неравенства из (\ref{planecoord}).
    Для этого произведем некоторые дополнительные преобразования.
    \[
      x^2 = \begin{pmatrix} x_o & x_a & x_b & x_c \end{pmatrix}
             \begin{pmatrix} 1 \\ \alpha \\ \beta \\ \gamma \end{pmatrix}
             \begin{pmatrix} x_o & x_a & x_b & x_c \end{pmatrix}
             \begin{pmatrix} 1 \\ \alpha \\ \beta \\ \gamma \end{pmatrix}
    \]
    Пусть $r = \begin{pmatrix} 1 \\ \alpha \\ \beta \\ \gamma \end{pmatrix} $,
          $v = \begin{pmatrix} x_o & x_a & x_b & x_c \end{pmatrix}$.
    Тогда
    \[
      x^2 = v r v r = (r^T v^T)^T v r
    \]
    Но $r^T v^T$ имеет размерность $1$x$1$, поэтому от транспонирования можно избавиться.
    \[
      x^2 = r^T (v^T v) r
    \]\[
      X_4 = (v^T v)
    \]
    Заметим, что $X_4$ задает квадратичную форму, эта матрица симметрична и вдобавок положительно определена.
    Мы помним, что в столбце $r$ есть две константы: $1$ и $\gamma$.
    Вынесем их из столбца, а соответствующие коэффициенты --- из формы.
    \[
      x^2 = r^T X_4 r =
        \begin{pmatrix} 1 & \alpha & \beta & \gamma \end{pmatrix}
        \begin{pmatrix}
              a_{11} & a_{12} & a_{13} & a_{14} \\
              a_{21} & a_{22} & a_{23} & a_{24} \\
              a_{31} & a_{32} & a_{33} & a_{34} \\
              a_{41} & a_{42} & a_{43} & a_{44} \\

        \end{pmatrix}
        \begin{pmatrix} 1 \\ \alpha \\ \beta \\ \gamma \end{pmatrix}  =
    \]\[
        = a_{11} + 2a_{12}\alpha + 2a_{13}\beta + 2a_{14}\gamma +
                 a_{22}\alpha^2 + 2a_{23}\alpha\beta + 2a_{24}\alpha\gamma +
                                  a_{33}\beta^2 + 2a_{34}\beta\gamma +
                                                  a_{44}\gamma^2  =
    \]\[
        = \begin{pmatrix} \alpha & \beta \end{pmatrix}
          \begin{pmatrix}
              a_{22} & a_{23} \\
              a_{32} & a_{33}
        \end{pmatrix}
        \begin{pmatrix} \alpha \\ \beta \end{pmatrix}
    %\]\[
      + \begin{pmatrix} 1 & \gamma \end{pmatrix}
          \begin{pmatrix}
              a_{11} & a_{14} \\
              a_{14} & a_{44}
        \end{pmatrix}
        \begin{pmatrix} 1 \\ \gamma \end{pmatrix}
      + 2\begin{pmatrix} 1 & \gamma \end{pmatrix}
          \begin{pmatrix}
              a_{12} & a_{13} \\
              a_{24} & a_{34}
        \end{pmatrix}
        \begin{pmatrix} \alpha \\ \beta \end{pmatrix}
    \]
    Введем обозначения для константы и составленных из констант матриц:

        $X_2 = \begin{pmatrix}
              a_{22} & a_{23} \\
              a_{32} & a_{33}
        \end{pmatrix}$,

        $b_X = 2\begin{pmatrix} 1 & \gamma \end{pmatrix}
          \begin{pmatrix}
              a_{12} & a_{13} \\
              a_{24} & a_{34}
        \end{pmatrix}$,

        $C_X = \begin{pmatrix} 1 & \gamma \end{pmatrix}
          \begin{pmatrix}
              a_{11} & a_{14} \\
              a_{14} & a_{44}
        \end{pmatrix}
        \begin{pmatrix} 1 \\ \gamma \end{pmatrix}$.

      Получим, что
      $x^2 = \begin{pmatrix} \alpha && \beta \end{pmatrix}
               X_2
             \begin{pmatrix} \alpha \\ \beta \end{pmatrix} +
             b_X \begin{pmatrix} \alpha \\ \beta \end{pmatrix}  +
             C_X$.

      Для $y^2$ получим аналогичные матрицы $Y_2$, $b_Y$, $C_Y$.

      Квадратичное неравенство из (\ref{cnb}) приведено к следующему виду:

      \begin{equation}\label{ineq}
            \begin{pmatrix} \alpha && \beta \end{pmatrix}
               (X_2 + Y_2)
             \begin{pmatrix} \alpha \\ \beta \end{pmatrix} +
             (b_X + b_Y) \begin{pmatrix} \alpha \\ \beta \end{pmatrix}  \le
             1 - C_X -C_Y
      \end{equation}
      Именно квадратичную функцию из левой части неравенства мы подвергнем условной минимизации.
      Запишем задачу квадратичного программирования.
      \begin{equation}\label{quadrtask}
          \begin{cases}
          \begin{pmatrix} \alpha && \beta \end{pmatrix}
               (X_2 + Y_2)
             \begin{pmatrix} \alpha \\ \beta \end{pmatrix} +
             (b_X + b_Y) \begin{pmatrix} \alpha \\ \beta \end{pmatrix} \to min \\
              0 \le  \alpha   \le  1 \\
              0 \le  \beta   \le  1 \\
              \gamma   =  1 \\
              0 \le  z_o + z_a \alpha + z_b \beta + z_c\gamma   \le  1
          \end{cases}
      \end{equation}
      Равенство $\gamma = 1$ сюда включено, конечно, только для наглядноcти подстановки в последнее неравенство.
      Оно примет вид $ -z_o - z_c \le  z_a \alpha + z_b \beta \le  1 -z_o - z_c$.
      Если минимум, который мы отыщем после оптимизации, будет меньше константы в правой части неравенства (\ref{ineq}), это будет значить наличие пересечения с гранью.
      В противном случае пересечения с этой гранью не будет.

      Итак, мы получили задачу квадратичного программирования для проверки наличия пересечения грани и цилиндра.
      Аналогично получим такие задачи для остальных пяти граней.
      Ниже описано получение из них задачи квадратичного программирования для ребре.
\section{Постановка задачи минимизации на ребре многоугольника}
  В (\ref{quadrtask}) включены три двойных неравенства.
  Их можно разбить и получить шесть простых.
  Обращая их в равенства, получим для некоторых уравнения прямых, содержащих в себе ребра многогранника.
  Некоторые прямые не содержат в себе ни одного ребра и вообще не проходят через многоугольник.
  Точки минимума, найденные на таких прямых, не будут учитываться; как они будут отсеяны, описано ниже.
  В общем случае задача квадратичного программирования для ребра поставлена так:
  \begin{equation}\label{task1dim}
          \begin{cases}
          \begin{pmatrix} \alpha && \beta \end{pmatrix}
               M
             \begin{pmatrix} \alpha \\ \beta \end{pmatrix} +
             b \begin{pmatrix} \alpha \\ \beta \end{pmatrix} \to min &(1) & (1)\\
             k \alpha + m \beta = C_1 & (2) \\
             0 \le  \alpha   \le  1  \\
             0 \le  \beta   \le  1  &(3)\\
              -z_o - z_c \le  z_a \alpha + z_b \beta \le  1 -z_o - z_c
          \end{cases}
      \end{equation}
  Здесь $k, m, C_1$ --- некоторые константы,
  $f$ --- линейное преобразование двух аргументов, возвращающее столбец из нескольких действительных чисел,
  а $C_2$ --- столбец той же размерности;
  $f(\alpha, \beta) \le C_2$ выполнено тогда и только тогда, когда каждая компонента $f(\alpha, \beta)$ не превосходит соответствующей компоненты $C_2$.
\section{Решение задачи минимизации на ребре многоугольника}
  Пусть $M = \begin{pmatrix} m_{11} & m_{12} \\ m_{21} & m_{22} \end{pmatrix}$,
        $b = \begin{pmatrix} b_1 && b_2 \end{pmatrix}$.
  Заменим в системе линейных уравнений $2M \begin{pmatrix} \alpha \\ \beta \end{pmatrix} = - b^T$ одну из строк на $\begin{pmatrix} k & m & C_1 \end{pmatrix}$,
  причем если $k=0$, заменим вторую строку, а иначе --- первую.
  Можем получить одну из следующих систем:
  \[
    \begin{pmatrix}
      k & 0 & \vrule & C_1 \\
      m_{21} & m_{22} & \vrule & b_2
    \end{pmatrix}
    \begin{pmatrix}
      k & m & \vrule & C_1 \\
      m_{21} & m_{22} & \vrule & b_2
    \end{pmatrix}
    \begin{pmatrix}
      m_{11} & m_{12} & \vrule & b_1 \\
      0 & m & \vrule & C_1
    \end{pmatrix}
  \]
  Получившаяся система задает точку минимума формы на прямой.
  Чтобы проверить, лежит ли она на ребре, подставим ее в условия (3) из (\ref{task1dim}).
  Тут можно заметить, что если прямая не включает в себя ни одного ребра, то есть проходит вне многоугольника,
  эта точка не будет удовлетворять условиям (3) и в итоговую выборку не попадет.
  Если минимум попал на ребро, вернем его.
  В противном случае переберем вершины.
  Для этого будем последовательно обращать неравенства из условий в равенства.
  Получим систему двух линейных уравнений: одно получено при постановке задачи на ребре, второе --- этим обращением в равенство.
  Если получившаяся система несовместная, то она не задает никакой вершины.
  Если же она совместная, то решив ее, получим точку, которая, возможно, является вершиной.
  Если мы включим в рассмотрение точки внутри ребра, они просто не дадут значения формы меньше, вершины.
  Поэтому необходимо из возможных вершин исключить те, что не лежат на ребре.
  Это можно сделать подстановкой в неравенства (3).
  Из оставшихся выберем то, для которой значение формы наименьшее.
  Если такой точки не нашлось, результатом будет ответ о невозможности найти минимум на ребре.
\section{Проверка попадания центра окружности в многоугольник}
  В главе "Переход к проекции"  говорилось, что круг может не иметь пересечения с ребром многоугольника,
  и, тем не менее, иметь пересечение с внутренней частью, если центр круга лежит внутри многоугольника.
  Наличие пересечения круга с ребрами было проверено в предыдущей части;
  теперь проверим принадлежность центра круга многоугольнику.

  Центр круга является проекцией отрезка на плоскость $xOy$.
  По сути необходимо проверить на пересечение параллелограмм и отрезок в пространстве.
  Возможны три принципиально разных ситуации:

  1) Отрезок может лежать на прямой, пересекающей плоскость;
  2) Отрезок может лежать на прямой, параллельной плоскости;
  3) Отрезок может лежать на прямой, содержащейся в плоскости.

  В первой ситуации координаты точки пересечения даются системой
  \[
    \begin{pmatrix}
     x_a & x_b & x_c & \vrule & 0\\
     y_a & y_b & y_c & \vrule & 0 \\
     0   & 0   & 1   & \vrule & 1
     \end{pmatrix}
  \]
  Если у этой системы решение есть, достаточно просто подставить его в условия (3), (4), (6) из \ref{proj}.
  Если же решения нет, то мы имеем дело с одной из последних двух ситуациях.
  В обеих, поскольку проиходит проецирование вдоль оси $Oz$ а плоскость этой оси параллельна, многоугольник выродится в отрезок.
  Значит, если центр круга и лежит внутри многоугольника, то это строго эквивалентно тому, что он лежит и на одном из его ребер.
  В таком случае мы бы отыскали его еще на предыдущем этапе.
  Таким образом, в этом случае проверять вообще ничего не нужно, мы все проверили ранее.
\section{Финальные проверки}
  Итак, найдены наименьшие значения форм на всех гранях. Это либо наименьшие из значений на ребрах, либо $0$, если центр круга попал внутрь многоугольника.
  Их необходимо сравнить с соответствующей константой в правой части (\ref{ineq}).
  Если хотя бы одно из наименьших значениях оказалось не больше константы, то точка пересечения найдена.
  Если все они превосходят константу, возможно, цилиндр вложен в параллелепипед.
  Проверим это.
  Для этого просто проверим, принадлежит ли точка $\begin{pmatrix}0 \\ 0 \\ 0 \end{pmatrix}$ параллелепипеду.
  Сделаем это, решив систему линейных уравнений
  \[
    \begin{pmatrix}
     x_a & x_b & x_c & \vrule & -x_o\\
     y_a & y_b & y_c & \vrule & -y_o \\
     z_a & z_b & z_c & \vrule & -z_o
     \end{pmatrix}
  \]
  Если его решение $\begin{pmatrix} \alpha \\ \beta \\ \gamma \end{pmatrix}$ такого, что все компоненты лежат между $0$ и $1$, начало координат попало в пареллелепипед, а значит, попал и весь цилиндр. Если нет, то значит, что точек пересечения у тел нет.
  Последнюю проверку можно было бы проводить и в самом начале, до решения задачи квадратичного программирования на гранях.
\clearpage

\chapter{Описание программы}

Программа написана на языке Python (версия 3.5.2) с использованием библиотеки numpy.
Полный листинг кода содержится в приложении.
Программа организована в три модуля.

\section{Модуль geometry}
Содержит классы cylinder и parallelepiped, описывающие соответственно цилиндр и параллелепипед.
Методы check обоих классов осуществляют проверку на корректность.
Методы get\_translation и get\_matrix класса cylinder возвращают описание базисного перехода.
Метод transform класса parallelepiped преобразует координаты векторов, задающих его, к координатам в новом базисе.
Метод get\_tasks класса parallelepiped возвращает список задач квадратичной оптимизации для каждой из грани параллелепипеда.
Он использует вспомогательные методы для нахождения необходимых подматриц $X_2, Y_2, b_X, b_Y$ и так далее, которые подробно описаны в
главе "Переход к задаче квадратичного программирования".

\section{Модуль quadratic\_programming}
Содержит три метода.
Метод calculate\_form\_value вспомогательный и используется для подсчета значения квадратичной формы для определенного вектора.
Метод solve\_1dim решает задачу оптимизации на отрезке.
Метод solve\_2dim получает на вход задачу квадратичной оптимизации на многограннике
и ставит соответствующие задачи на ребрах этого многогранника, а также проверяет, не попал ли центр проекции основания эллипса
на плоскость $xOy$ внутрь многогранника.

\section{Модуль main}
Содержит описание основной последовательности действий.
Производится считываение входа, затем вход проверяется на корректность при помощи
методов check классов модуля geometry.
Затем вызывается метод get\_tasks, и полученные задачи решаются вызовом метода solve\_2dim
модуля quadratic\_programming для каждой из полученных задач.


\chapter{Заключение}
\section{Итоги работы}
  Описан алгоритм обнаружения столкновения между произвольными цилиндром и параллелепипедом.
  По ходу описания приведено и обоснование корректности.
  Также написана программа, реализующая описанный алгоритм, на языке программирования Python3.
\section{Возможное развитие}
  Описанный алгоритм корректен, но не оптимален.
  Возможно введение оптимизаций: уменьшение числа перебираемых ребер, граней.
  Кроме того, не рассмотрен случай сектора цилиндра и бесконечного параллелепипеда.
\clearpage

\chapter{Список литературы}
[1] Абагян Л.В., Алексеев Н.И., Брызгалов В.И., Гомин Е.А., Гуревич М.И. и др. Программа MCU-RFFI/Aс библиотекой констант DLC/MCUDAT-1.0 (аннотация
 программы, аттестованной Госатомнадзором РФ). ВАНТ. Сер.: Физика ядерных реакторов, 2001, вып. 3, с.50-55.

[2] Дж.Спанье, Э.Гелбард "Метод Монте-Карло и задача переноса нейтронов."
[М]сква, Атомиздат 1972 г

[3] Алексеев Н.И., Больщагин С.Н., Гомин Е.А. и др. "Статус МСU 5", ВАНТ серия Физика ядерных реакторов, выпуск 4 2011 г.

[4] MCNP - A General Monte Carlo N-Particle Transport Code. Version 4A, LA-12625-M 1993.

[5] Гуревич М.И., Шкаровский Д.А. "Расчет переноса нейтронов методом Монте-Карло по программе MCU", Национальный исследовательский ядерный университет
 «МИФИ», Москва 2012 г.

[6] J. Frédéric Bonnans · J. Charles Gilbert
Claude Lemaréchal · Claudia A. Sagastizábal "Numerical Optimization - Theoretical and Practical Aspects. 2nd Edition." Spinger 2006

\clearpage

\chapter{Приложение}

\textbf{Листинг модуля geometry}

\begin{verbatim}
import numpy as np
from numpy import linalg as la

class cylinder: # Класс, описывающий цилиндр
  def __init__(self, o, a, b, c):
        # o - центр основания, a, b - оси эллпса, c - центральная ось цилиндра
      self.o = o
      self.a = a
      self.b = b
      self.c = c

  def check(self): # Проверка корректности задания цилиндра
      if np.all(np.matmul(np.transpose(self.a), self.b) == 0):
                  # a и b должны быть ортогональны
          matr = np.hstack((self.a, self.b, self.c))
                  # a, b и c должны быть ЛНЗ системой
          if la.det(matr) != 0:
              return True
      return False

  def get_translation(self):
      # Возвращает вектор параллельного переноса (для смены базиса)
      return -self.o

  def get_matrix(self):
      # Возвращет матрицу перехода в базис (a, b, c)
      return la.inv(np.hstack((self.a, self.b, self.c)))


class parallelepiped: # Класс, описывающий параллелограмм
  def __init__(self, o, a, b, c):
      self.o = o
      self.a = a
      self.b = b
      self.c = c

  def check(self):
      # Проверка корректности задания цилиндра
      matr = np.hstack((self.a, self.b, self.c))
      # a, b и c должны быть ЛНЗ системой
      if la.det(matr) != 0:
          return True
      return False

  def transform(self, matr, delta): # Преобразование координат
      self.o = np.matmul(matr, self.o + delta) # delta - вектор переноса
      self.a = np.matmul(matr, self.a)         # matr - матрица перехода
      self.b = np.matmul(matr, self.b)
      self.c = np.matmul(matr, self.c)

  def _get_X_4(self):           # Возвращает матрицу X_4 (описана в тексте)
      matr = np.hstack((self.o, self.a, self.b, self.c))
      v = [matr[0, ]]
      return np.matmul(np.transpose(v), v)

  def _get_Y_4(self): # Возвращает матрицу Y_4 (описана в тексте)
      matr = np.hstack((self.o, self.a, self.b, self.c))
      v = [matr[1, ]]
      return np.matmul(np.transpose(v), v)

  def _get_2_projection(self, matr, coord_num): # Возвращает X_2 или Y_2
      rows = np.vstack((matr[1:coord_num], matr[coord_num + 1:]))
      m = np.hstack((rows[:, 1:coord_num], rows[:, coord_num + 1:]))
      return m

  def _get_b(self, matr, coord_num, val):      # Возвращает b_X или b_Y
      rows = np.vstack((matr[0], matr[coord_num]))
      m = np.hstack((rows[:, 1:coord_num], rows[:, coord_num + 1:]))
      return 2 * np.matmul(np.array([1, val]), m)

  def _get_C(self, matr, coord_num, val):     # Возвращает C_x или C_y
      rows = np.vstack((matr[0], matr[coord_num]))
      m = np.hstack((np.transpose([rows[:, 0]]),
      np.transpose([rows[:, coord_num]])))
      r = np.array([1, val])
      return np.matmul(np.matmul(r, m), np.transpose(m))[0]

  def _get_z_coefs(self, coord):
     # Возвращает коэффициенты из неравенства, вытекающего из ограничения по z
      matr = np.hstack((self.o, self.a, self.b, self.c))
      v = matr[2,:]
      return np.hstack((v[1:coord], v[coord + 1:]))

  def _get_z_const(self, coord, val):
      # Возвращает константы из неравенства, вытекающего из ограничения по z
      matr = np.hstack((self.o, self.a, self.b, self.c))
      v = matr[2,:]
      const = v[0] + v[coord] * val
      return np.array([[1 - const], [-const]])

  def _get_cyl_axis_cross_plane(self, coord, val):
               # Находим координаты (внутренние для параллелепипеда)
               # пересечения оси Oz с гранью
      matr = np.hstack((self.o, self.a, self.b, self.c))
      rows = matr[:2]
      left = np.hstack((self.a, self.b, self.c))
      left = left[:2]
      right =  - self.o[:2]
      left_last = np.array([[0, 0, 0]])
      left_last[0, coord - 1] = 1
      left = np.vstack((left, left_last))
      right = np.vstack((right, np.array([[val]])))
      if la.det(left) == 0:       # Если система не имеет решения,
          return 0                # проверку проводить не будем.
      r = la.solve(left, right)
  # Находим координаты (внутренние для параллелепипеда) пересечения оси и грани
      r = np.delete(r, coord - 1, 0)
      # Удаляем константную координату
      return r

  def get_tasks(self):
      # Постановка задач оптимизации на гранях
      # Названия - как в описании
      X_4 = self._get_X_4()
      Y_4 = self._get_Y_4()
      tasks = []
      for coord in (1, 2, 3):
          # Описание всех граней: каждая грань - пара из номера
          for val in (0., 1.):
          # внутренней координаты, обращенной в константу, и константы (0 или 1)
              M = (self._get_2_projection(X_4, coord) +
                      self._get_2_projection(Y_4, coord))
              b = self._get_b(X_4, coord, val) + self._get_b(Y_4, coord, val)
              C = (1 - self._get_C(X_4, coord, val) -
               self._get_C(Y_4, coord, val))
              conds = np.vstack((np.eye(2), -np.eye(2)))
              cond_const = np.transpose(np.array([[1, 1, 0, 0]]))
              # Задаем ограничения по изменяющимся внутренним координатам
              conds = np.vstack((conds, self._get_z_coefs(coord), -
              self._get_z_coefs(coord)))
              cond_const = (
              np.vstack((cond_const, self._get_z_const(coord, val))))
              # Задаем ограничения по z
              r = self._get_cyl_axis_cross_plane(coord, val)
              # Находим координаты пересечения
              tasks.append((M, b, conds, cond_const, C, r))
              # Добавляем кортеж, задающий систему неравенств, наличие решения
              # равнозначно наличию пересечения грани и цилиндра

      return tasks

  def check_begin_inside(self):
      # Проверяем принадлежность точки (0, 0, 0) параллелограмму
      matr = np.hstack((self.a, self.b, self.c))
      r = la.solve(matr, -self.o)
      return np.all(r <= 1) and np.all(r >=0)
\end{verbatim}

\textbf{Листинг модуля quadr\_programming}

\begin{verbatim}
import numpy as np
import geometry as geom
from numpy import linalg as la

def calculate_form_value(M, b, vec):
              # Подсчет значения формы M(x,x) - b(x) на векторе vec
  res = np.dot(np.transpose(vec),
  np.dot(M, vec)) + np.dot(np.transpose(b), vec)
  try :
      return res[0, 0]
  except IndexError:
      return res

def solve_1dim(M, b, cond, cond_const, cond_eq, cond_eq_const):
  eq_index = 0
  free_index = 1
  M_diff = 2 * M
  b_diff = -b

  if cond_eq[0] == 0:
      eq_index = 1
      free_index = 0

  M_diff[eq_index] = cond_eq
  b[eq_index] = cond_eq_const
  force_vert_check = False
  if la.det(M_diff) == 0: # На прямой расстояние до оси может  не меняться
       # В этом случае минимум - форма на какой-нибудь точке отрезка
      force_vert_check = True  # Например, на вершине
  else:
      linear_global_min = la.solve(M_diff, b)
  # Ищем минимум на прямой, содержащей ребро
      conditions_check = np.matmul(cond, linear_global_min)
      inside = np.all(np.less_equal(conditions_check, cond_const))
      if inside:      # Проверяем, что минимум лежит внутри ребра
          return (linear_global_min, calculate_form_value(M, b, linear_global_min))
             # Проверяем вершины
  minval = 100
  minvert = np.array([[-1000], [-1000]])
  for i in range(b.shape[0]):
      A_matr = np.vstack((cond_eq, M[i]))
      if la.det(A_matr) != 0:
          b_matr = np.array([[cond_eq_const], [b[i]]])
          vertex = la.solve(A_matr, b_matr)
          conditions_check = np.matmul(cond, vertex)
              # Проверяем, что отобранная точка действительно вершина
          inside = np.all(np.less_equal(conditions_check, cond_const))
          if inside:
              vert_val = calculate_form_value(M, b, vertex)
              if vert_val < minval:
                  minval = vert_val
                  minvert = vertex
  return(minvert, minval)

def solve_2dim(task):
  # Минимизируем функция M(x, x) - bx на ребрах многоугольника, заданной
  # условиями cond*x <= cond_const, сравниваем минимум с константой C
  # Проверяем, не попал ли центр эллипса внутрь многоугольника.
  (M, b, cond, cond_const, C, r) = task
  minval = 100
  minpoint = np.array([[-1000], [-1000]])
  for i in range(cond_const.shape[0]):
      (curpoint, curval) = solve_1dim(M, b,
          np.delete(cond, i, 0), np.delete(cond_const, i, 0),
          cond[i], cond_const[i, 0] )     # Ищем минимум на ребре
      if curval < minval:
          minval = curval
          minpoint = curpoint
          # Устанавливаем минимум на всех ребрах
  if minval <= C:
      # Если минимум на ребрах нас устроил, сообщаем о наличии пересечения
      return True

  if type(r) == type(0):  # Если ось Oz параллельна плоскости многоугольнка,
              # все возможные проверки уже пройдены.
      return False
  conditions_check = np.matmul(cond, r)
  # Проверяем принадлежность центра внутренности многоугольника
  center_inside = np.all(np.less_equal(conditions_check, cond_const))
  return center_inside

\end{verbatim}

\textbf{Листинг модуля main}
\begin{verbatim}
import numpy as np
import geometry as geom
from numpy import linalg as la
from quadr_programming import solve_2dim

def read_vector():                  # Ввод координат вектора в 3м пространстве
  inp = input()
  coords = inp.split(' ')         # Координаты вводятся через пробел
  if len(coords) != 3:            # Если меньше трех координат,
                                  # дать еще попытку
      print('Must be 3 coords, try again')
      return(read_vector())
  vec = []
  for i in range(3):
      x = float(coords[i])
      vec += [[x]]            # Преобразуем к столбцу
  return np.array(vec)

c = geom.cylinder(read_vector(), read_vector(), read_vector(), read_vector())
# Считываем цилиндр
if not c.check():   # Проверяем корректность задания цилиндра
  print("Incorrect cylinder, exiting")
  exit()
p = geom.parallelepiped(read_vector(),
read_vector(), read_vector(), read_vector())
# Считываем параллелограмм
if not p.check():   # Проверяем корректность задания параллелограмма
  print("Incorrect parallelepiped, exiting")
  exit()
p.transform(c.get_matrix(), c.get_translation())
  # Проводим преобразование базиса

tasks = p.get_tasks()   # Решаем задачу на гранях
for task in tasks:
  if solve_2dim(task):
      print("Cross found")
      exit()

if p.check_begin_inside():  # Если на гранях пересечения не нашли,
                          # проверяем вложенность
  print("Cross found")
  exit()

print("Cross not found")    # Если и вложенности нет, пересечений нет вообще

\end{verbatim}

\end{document}
